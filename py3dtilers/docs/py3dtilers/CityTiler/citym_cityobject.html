<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>py3dtilers.CityTiler.citym_cityobject API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>py3dtilers.CityTiler.citym_cityobject</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
from io import BytesIO
from py3dtiles import TriangleSoup
import os

from ..Common import Feature, FeatureList
from ..Texture import Texture


class CityMCityObject(Feature):
    &#34;&#34;&#34;
    The base class of all thematic classes within CityGMLâ€™s data model is the abstract class
    _CityObject. (cf 3DCityDB Version 3.3.0 Documentation).
    &#34;&#34;&#34;

    def __init__(self, database_id=None, gml_id=None):
        super().__init__(database_id)
        self.set_gml_id(gml_id)
        self.texture_uri = None

    def get_database_id(self):
        &#34;&#34;&#34;
        Return the database id of this object. The id from the database is used as the main id.
        :return: the id of the object
        &#34;&#34;&#34;
        return super().get_id()

    def set_database_id(self, id):
        &#34;&#34;&#34;
        Set the database id of this object. The id from the database is used as the main id.
        :param id: the id
        &#34;&#34;&#34;
        super().set_id(id)

    def set_gml_id(self, gml_id):
        &#34;&#34;&#34;
        Set the gml id of this object. The gml id is kept into the batch table.
        :param gml_id: the id of the object
        &#34;&#34;&#34;
        batch_table_data = {
            &#39;gml_id&#39;: gml_id
        }
        super().set_batchtable_data(batch_table_data)

    def get_gml_id(self):
        &#34;&#34;&#34;
        :return: the (city)gml identifier of an object that should be encountered
                in the database.
        &#34;&#34;&#34;
        return super().get_batchtable_data()[&#39;gml_id&#39;]

    def has_texture(self):
        &#34;&#34;&#34;
        Return True if the feature has a texture URI.
        :return: a boolean
        &#34;&#34;&#34;
        return self.texture_uri is not None

    def get_geom(self, user_arguments=None, feature_list=None, material_indexes=dict()):
        &#34;&#34;&#34;
        Set the geometry of the feature.
        :return: a list of Feature
        &#34;&#34;&#34;
        id = &#39;(&#39; + str(self.get_database_id()) + &#39;)&#39;
        cursor = self.objects_type.get_cursor()
        cityobjects_with_geom = list()
        if user_arguments.with_texture:
            cursor.execute(self.objects_type.sql_query_geometries_with_texture_coordinates(id))
        else:
            cursor.execute(self.objects_type.sql_query_geometries(id, user_arguments.split_surfaces))
        for t in cursor.fetchall():
            try:
                feature_id = t[0]
                geom_as_string = t[1]
                if geom_as_string is not None:
                    cityobject = self.__class__(feature_id, self.get_gml_id())
                    associated_data = []

                    if user_arguments.with_texture:
                        uv_as_string = t[2]
                        texture_uri = t[3]
                        cityobject.texture_uri = texture_uri
                        associated_data = [uv_as_string]
                    elif user_arguments.add_color:
                        surface_classname = t[2]
                        if surface_classname not in material_indexes:
                            material = feature_list.get_color_config().get_color_by_key(surface_classname)
                            material_indexes[surface_classname] = len(feature_list.materials)
                            feature_list.add_materials([material])
                        cityobject.material_index = material_indexes[surface_classname]

                    cityobject.geom = TriangleSoup.from_wkb_multipolygon(geom_as_string, associated_data)
                    if len(cityobject.geom.triangles[0]) &gt; 0:
                        cityobject.set_box()
                        cityobject.centroid = self.centroid
                        cityobjects_with_geom.append(cityobject)
            except Exception:
                continue
        return cityobjects_with_geom


class CityMCityObjects(FeatureList):
    &#34;&#34;&#34;
    A decorated list of CityMCityObject type objects.
    &#34;&#34;&#34;

    object_type = CityMCityObject

    gml_cursor = None

    def __init__(self, cityMCityObjects=None):
        if self.color_config is None:
            config_path = os.path.join(os.path.dirname(__file__), &#34;..&#34;, &#34;Color&#34;, &#34;citytiler_config.json&#34;)
            self.set_color_config(config_path)
        super().__init__(cityMCityObjects)

    def get_textures(self):
        &#34;&#34;&#34;
        Return a dictionary of all the textures where the keys are the IDs of the features.
        :return: a dictionary of textures
        &#34;&#34;&#34;
        texture_dict = dict()
        uri_dict = dict()
        for feature in self.get_features():
            uri = feature.texture_uri
            if uri not in uri_dict:
                stream = self.get_image_from_binary(uri, self.__class__, CityMCityObjects.gml_cursor)
                uri_dict[uri] = Texture(stream)
            texture_dict[feature.get_id()] = uri_dict[uri].get_cropped_texture_image(feature.geom.triangles[1])
        return texture_dict

    @staticmethod
    def set_cursor(cursor):
        &#34;&#34;&#34;
        Set the CityMCityObjects cursor to the current cursor to be able to execute queries in the database.
        :param cursor: the cursor of the current database
        &#34;&#34;&#34;
        CityMCityObjects.gml_cursor = cursor

    @staticmethod
    def get_cursor():
        &#34;&#34;&#34;
        Return the current cursor to be able to execute queries in the database.
        :return: the cursor of the current database
        &#34;&#34;&#34;
        return CityMCityObjects.gml_cursor

    @staticmethod
    def sql_query_objects():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def retrieve_objects(cursor, objects_type, cityobjects=list(), citygml_ids=list()):
        &#34;&#34;&#34;
        :param cursor: a database access cursor.
        :param objects_type: a class name among CityMCityObject derived classes.
                        For example, objects_type can be &#34;CityMBuilding&#34;.

        :param cityobjects: a list of objects_type type object that should be
                        sought in the database. When this list is empty all
                        the objects encountered in the database are returned.

        :param citygml_ids: a list of cityGML IDs. If the list isn&#39;t empty, we keep only
                        the city objects of the list

        :return: an objects_type type object containing the objects that were retrieved
                in the 3DCityDB database, each object being decorated with its database
                identifier as well as its 3D bounding box (as retrieved in the database).
        &#34;&#34;&#34;
        if not cityobjects:
            no_input = True
        else:
            no_input = False
        cursor.execute(objects_type.sql_query_objects(cityobjects, citygml_ids))

        if no_input:
            result_objects = objects_type()
            object_type = objects_type.object_type
        else:
            # We need to deal with the fact that the answer will (generically)
            # not preserve the order of the objects that was given to the query
            objects_with_gmlid_key = dict()
            for cityobject in cityobjects:
                objects_with_gmlid_key[cityobject.get_gml_id()] = cityobject

        for obj in cursor.fetchall():
            object_id = obj[0]
            gml_id = obj[1]
            if no_input:
                new_object = object_type(object_id, gml_id)
                result_objects.append(new_object)
            else:
                cityobject = objects_with_gmlid_key[gml_id]
                cityobject.set_database_id(object_id)
                cityobject.set_gml_id(gml_id)
        if no_input:
            return result_objects
        else:
            return cityobjects

    @staticmethod
    def sql_query_geometries():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def sql_query_textures(image_uri):
        &#34;&#34;&#34;
        :param image_uri: a string which is the uri of the texture to select in the database
        :return: a string containing the right SQL query that should be executed.
        &#34;&#34;&#34;

        query = \
            &#34;SELECT tex_image_data FROM citydb.tex_image WHERE tex_image_uri = &#39;&#34; + image_uri + &#34;&#39; &#34;
        return query

    @staticmethod
    def retrieve_textures(cursor, image_uri, objects_type):
        &#34;&#34;&#34;
        :param cursor: a database access cursor
        :param image_uri: the uri (as string) of the texture to select in the database
        :param objects_type: a class name among CityMCityObject derived classes.
                        For example, objects_type can be &#34;CityMBuilding&#34;.
        :rtype List: the binary data of the texture image
        &#34;&#34;&#34;
        res = []
        cursor.execute(objects_type.sql_query_textures(image_uri))
        for t in cursor.fetchall():
            res.append(t)
        return(res)

    @staticmethod
    def get_image_from_binary(textureUri, objects_type, cursor):
        &#34;&#34;&#34;
        Return the texture image as a byte stream.
        :param textureUri: the URI of the texture image.
        :param objects_type: a class name among CityMCityObject derived classes.
        :param cursor: a database access cursor
        :return: an image as bytes
        &#34;&#34;&#34;
        imageBinaryData = objects_type.retrieve_textures(
            cursor,
            textureUri,
            objects_type)
        LEFT_THUMB = imageBinaryData[0][0]
        stream = BytesIO(LEFT_THUMB)
        return stream

    @staticmethod
    def sql_query_centroid():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def sql_query_geometries_with_texture_coordinates():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject"><code class="flex name class">
<span>class <span class="ident">CityMCityObject</span></span>
<span>(</span><span>database_id=None, gml_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The base class of all thematic classes within CityGMLâ€™s data model is the abstract class
_CityObject. (cf 3DCityDB Version 3.3.0 Documentation).</p>
<p>:param id: given identifier</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CityMCityObject(Feature):
    &#34;&#34;&#34;
    The base class of all thematic classes within CityGMLâ€™s data model is the abstract class
    _CityObject. (cf 3DCityDB Version 3.3.0 Documentation).
    &#34;&#34;&#34;

    def __init__(self, database_id=None, gml_id=None):
        super().__init__(database_id)
        self.set_gml_id(gml_id)
        self.texture_uri = None

    def get_database_id(self):
        &#34;&#34;&#34;
        Return the database id of this object. The id from the database is used as the main id.
        :return: the id of the object
        &#34;&#34;&#34;
        return super().get_id()

    def set_database_id(self, id):
        &#34;&#34;&#34;
        Set the database id of this object. The id from the database is used as the main id.
        :param id: the id
        &#34;&#34;&#34;
        super().set_id(id)

    def set_gml_id(self, gml_id):
        &#34;&#34;&#34;
        Set the gml id of this object. The gml id is kept into the batch table.
        :param gml_id: the id of the object
        &#34;&#34;&#34;
        batch_table_data = {
            &#39;gml_id&#39;: gml_id
        }
        super().set_batchtable_data(batch_table_data)

    def get_gml_id(self):
        &#34;&#34;&#34;
        :return: the (city)gml identifier of an object that should be encountered
                in the database.
        &#34;&#34;&#34;
        return super().get_batchtable_data()[&#39;gml_id&#39;]

    def has_texture(self):
        &#34;&#34;&#34;
        Return True if the feature has a texture URI.
        :return: a boolean
        &#34;&#34;&#34;
        return self.texture_uri is not None

    def get_geom(self, user_arguments=None, feature_list=None, material_indexes=dict()):
        &#34;&#34;&#34;
        Set the geometry of the feature.
        :return: a list of Feature
        &#34;&#34;&#34;
        id = &#39;(&#39; + str(self.get_database_id()) + &#39;)&#39;
        cursor = self.objects_type.get_cursor()
        cityobjects_with_geom = list()
        if user_arguments.with_texture:
            cursor.execute(self.objects_type.sql_query_geometries_with_texture_coordinates(id))
        else:
            cursor.execute(self.objects_type.sql_query_geometries(id, user_arguments.split_surfaces))
        for t in cursor.fetchall():
            try:
                feature_id = t[0]
                geom_as_string = t[1]
                if geom_as_string is not None:
                    cityobject = self.__class__(feature_id, self.get_gml_id())
                    associated_data = []

                    if user_arguments.with_texture:
                        uv_as_string = t[2]
                        texture_uri = t[3]
                        cityobject.texture_uri = texture_uri
                        associated_data = [uv_as_string]
                    elif user_arguments.add_color:
                        surface_classname = t[2]
                        if surface_classname not in material_indexes:
                            material = feature_list.get_color_config().get_color_by_key(surface_classname)
                            material_indexes[surface_classname] = len(feature_list.materials)
                            feature_list.add_materials([material])
                        cityobject.material_index = material_indexes[surface_classname]

                    cityobject.geom = TriangleSoup.from_wkb_multipolygon(geom_as_string, associated_data)
                    if len(cityobject.geom.triangles[0]) &gt; 0:
                        cityobject.set_box()
                        cityobject.centroid = self.centroid
                        cityobjects_with_geom.append(cityobject)
            except Exception:
                continue
        return cityobjects_with_geom</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.feature.Feature" href="../Common/feature.html#py3dtilers.Common.feature.Feature">Feature</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.citym_bridge.CityMBridge" href="citym_bridge.html#py3dtilers.CityTiler.citym_bridge.CityMBridge">CityMBridge</a></li>
<li><a title="py3dtilers.CityTiler.citym_building.CityMBuilding" href="citym_building.html#py3dtilers.CityTiler.citym_building.CityMBuilding">CityMBuilding</a></li>
<li><a title="py3dtilers.CityTiler.citym_relief.CityMRelief" href="citym_relief.html#py3dtilers.CityTiler.citym_relief.CityMRelief">CityMRelief</a></li>
<li><a title="py3dtilers.CityTiler.citym_waterbody.CityMWaterBody" href="citym_waterbody.html#py3dtilers.CityTiler.citym_waterbody.CityMWaterBody">CityMWaterBody</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_database_id"><code class="name flex">
<span>def <span class="ident">get_database_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the database id of this object. The id from the database is used as the main id.
:return: the id of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_database_id(self):
    &#34;&#34;&#34;
    Return the database id of this object. The id from the database is used as the main id.
    :return: the id of the object
    &#34;&#34;&#34;
    return super().get_id()</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_geom"><code class="name flex">
<span>def <span class="ident">get_geom</span></span>(<span>self, user_arguments=None, feature_list=None, material_indexes={})</span>
</code></dt>
<dd>
<div class="desc"><p>Set the geometry of the feature.
:return: a list of Feature</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geom(self, user_arguments=None, feature_list=None, material_indexes=dict()):
    &#34;&#34;&#34;
    Set the geometry of the feature.
    :return: a list of Feature
    &#34;&#34;&#34;
    id = &#39;(&#39; + str(self.get_database_id()) + &#39;)&#39;
    cursor = self.objects_type.get_cursor()
    cityobjects_with_geom = list()
    if user_arguments.with_texture:
        cursor.execute(self.objects_type.sql_query_geometries_with_texture_coordinates(id))
    else:
        cursor.execute(self.objects_type.sql_query_geometries(id, user_arguments.split_surfaces))
    for t in cursor.fetchall():
        try:
            feature_id = t[0]
            geom_as_string = t[1]
            if geom_as_string is not None:
                cityobject = self.__class__(feature_id, self.get_gml_id())
                associated_data = []

                if user_arguments.with_texture:
                    uv_as_string = t[2]
                    texture_uri = t[3]
                    cityobject.texture_uri = texture_uri
                    associated_data = [uv_as_string]
                elif user_arguments.add_color:
                    surface_classname = t[2]
                    if surface_classname not in material_indexes:
                        material = feature_list.get_color_config().get_color_by_key(surface_classname)
                        material_indexes[surface_classname] = len(feature_list.materials)
                        feature_list.add_materials([material])
                    cityobject.material_index = material_indexes[surface_classname]

                cityobject.geom = TriangleSoup.from_wkb_multipolygon(geom_as_string, associated_data)
                if len(cityobject.geom.triangles[0]) &gt; 0:
                    cityobject.set_box()
                    cityobject.centroid = self.centroid
                    cityobjects_with_geom.append(cityobject)
        except Exception:
            continue
    return cityobjects_with_geom</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_gml_id"><code class="name flex">
<span>def <span class="ident">get_gml_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>:return: the (city)gml identifier of an object that should be encountered
in the database.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_gml_id(self):
    &#34;&#34;&#34;
    :return: the (city)gml identifier of an object that should be encountered
            in the database.
    &#34;&#34;&#34;
    return super().get_batchtable_data()[&#39;gml_id&#39;]</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.has_texture"><code class="name flex">
<span>def <span class="ident">has_texture</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if the feature has a texture URI.
:return: a boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_texture(self):
    &#34;&#34;&#34;
    Return True if the feature has a texture URI.
    :return: a boolean
    &#34;&#34;&#34;
    return self.texture_uri is not None</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.set_database_id"><code class="name flex">
<span>def <span class="ident">set_database_id</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the database id of this object. The id from the database is used as the main id.
:param id: the id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_database_id(self, id):
    &#34;&#34;&#34;
    Set the database id of this object. The id from the database is used as the main id.
    :param id: the id
    &#34;&#34;&#34;
    super().set_id(id)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.set_gml_id"><code class="name flex">
<span>def <span class="ident">set_gml_id</span></span>(<span>self, gml_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the gml id of this object. The gml id is kept into the batch table.
:param gml_id: the id of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_gml_id(self, gml_id):
    &#34;&#34;&#34;
    Set the gml id of this object. The gml id is kept into the batch table.
    :param gml_id: the id of the object
    &#34;&#34;&#34;
    batch_table_data = {
        &#39;gml_id&#39;: gml_id
    }
    super().set_batchtable_data(batch_table_data)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.feature.Feature" href="../Common/feature.html#py3dtilers.Common.feature.Feature">Feature</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.feature.Feature.get_batchtable_data" href="../Common/feature.html#py3dtilers.Common.feature.Feature.get_batchtable_data">get_batchtable_data</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.get_bounding_volume_box" href="../Common/feature.html#py3dtilers.Common.feature.Feature.get_bounding_volume_box">get_bounding_volume_box</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.get_centroid" href="../Common/feature.html#py3dtilers.Common.feature.Feature.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.get_geom_as_triangles" href="../Common/feature.html#py3dtilers.Common.feature.Feature.get_geom_as_triangles">get_geom_as_triangles</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.get_id" href="../Common/feature.html#py3dtilers.Common.feature.Feature.get_id">get_id</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.get_texture" href="../Common/feature.html#py3dtilers.Common.feature.Feature.get_texture">get_texture</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.set_batchtable_data" href="../Common/feature.html#py3dtilers.Common.feature.Feature.set_batchtable_data">set_batchtable_data</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.set_box" href="../Common/feature.html#py3dtilers.Common.feature.Feature.set_box">set_box</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.set_id" href="../Common/feature.html#py3dtilers.Common.feature.Feature.set_id">set_id</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.set_texture" href="../Common/feature.html#py3dtilers.Common.feature.Feature.set_texture">set_texture</a></code></li>
<li><code><a title="py3dtilers.Common.feature.Feature.set_triangles" href="../Common/feature.html#py3dtilers.Common.feature.Feature.set_triangles">set_triangles</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects"><code class="flex name class">
<span>class <span class="ident">CityMCityObjects</span></span>
<span>(</span><span>cityMCityObjects=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A decorated list of CityMCityObject type objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CityMCityObjects(FeatureList):
    &#34;&#34;&#34;
    A decorated list of CityMCityObject type objects.
    &#34;&#34;&#34;

    object_type = CityMCityObject

    gml_cursor = None

    def __init__(self, cityMCityObjects=None):
        if self.color_config is None:
            config_path = os.path.join(os.path.dirname(__file__), &#34;..&#34;, &#34;Color&#34;, &#34;citytiler_config.json&#34;)
            self.set_color_config(config_path)
        super().__init__(cityMCityObjects)

    def get_textures(self):
        &#34;&#34;&#34;
        Return a dictionary of all the textures where the keys are the IDs of the features.
        :return: a dictionary of textures
        &#34;&#34;&#34;
        texture_dict = dict()
        uri_dict = dict()
        for feature in self.get_features():
            uri = feature.texture_uri
            if uri not in uri_dict:
                stream = self.get_image_from_binary(uri, self.__class__, CityMCityObjects.gml_cursor)
                uri_dict[uri] = Texture(stream)
            texture_dict[feature.get_id()] = uri_dict[uri].get_cropped_texture_image(feature.geom.triangles[1])
        return texture_dict

    @staticmethod
    def set_cursor(cursor):
        &#34;&#34;&#34;
        Set the CityMCityObjects cursor to the current cursor to be able to execute queries in the database.
        :param cursor: the cursor of the current database
        &#34;&#34;&#34;
        CityMCityObjects.gml_cursor = cursor

    @staticmethod
    def get_cursor():
        &#34;&#34;&#34;
        Return the current cursor to be able to execute queries in the database.
        :return: the cursor of the current database
        &#34;&#34;&#34;
        return CityMCityObjects.gml_cursor

    @staticmethod
    def sql_query_objects():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def retrieve_objects(cursor, objects_type, cityobjects=list(), citygml_ids=list()):
        &#34;&#34;&#34;
        :param cursor: a database access cursor.
        :param objects_type: a class name among CityMCityObject derived classes.
                        For example, objects_type can be &#34;CityMBuilding&#34;.

        :param cityobjects: a list of objects_type type object that should be
                        sought in the database. When this list is empty all
                        the objects encountered in the database are returned.

        :param citygml_ids: a list of cityGML IDs. If the list isn&#39;t empty, we keep only
                        the city objects of the list

        :return: an objects_type type object containing the objects that were retrieved
                in the 3DCityDB database, each object being decorated with its database
                identifier as well as its 3D bounding box (as retrieved in the database).
        &#34;&#34;&#34;
        if not cityobjects:
            no_input = True
        else:
            no_input = False
        cursor.execute(objects_type.sql_query_objects(cityobjects, citygml_ids))

        if no_input:
            result_objects = objects_type()
            object_type = objects_type.object_type
        else:
            # We need to deal with the fact that the answer will (generically)
            # not preserve the order of the objects that was given to the query
            objects_with_gmlid_key = dict()
            for cityobject in cityobjects:
                objects_with_gmlid_key[cityobject.get_gml_id()] = cityobject

        for obj in cursor.fetchall():
            object_id = obj[0]
            gml_id = obj[1]
            if no_input:
                new_object = object_type(object_id, gml_id)
                result_objects.append(new_object)
            else:
                cityobject = objects_with_gmlid_key[gml_id]
                cityobject.set_database_id(object_id)
                cityobject.set_gml_id(gml_id)
        if no_input:
            return result_objects
        else:
            return cityobjects

    @staticmethod
    def sql_query_geometries():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def sql_query_textures(image_uri):
        &#34;&#34;&#34;
        :param image_uri: a string which is the uri of the texture to select in the database
        :return: a string containing the right SQL query that should be executed.
        &#34;&#34;&#34;

        query = \
            &#34;SELECT tex_image_data FROM citydb.tex_image WHERE tex_image_uri = &#39;&#34; + image_uri + &#34;&#39; &#34;
        return query

    @staticmethod
    def retrieve_textures(cursor, image_uri, objects_type):
        &#34;&#34;&#34;
        :param cursor: a database access cursor
        :param image_uri: the uri (as string) of the texture to select in the database
        :param objects_type: a class name among CityMCityObject derived classes.
                        For example, objects_type can be &#34;CityMBuilding&#34;.
        :rtype List: the binary data of the texture image
        &#34;&#34;&#34;
        res = []
        cursor.execute(objects_type.sql_query_textures(image_uri))
        for t in cursor.fetchall():
            res.append(t)
        return(res)

    @staticmethod
    def get_image_from_binary(textureUri, objects_type, cursor):
        &#34;&#34;&#34;
        Return the texture image as a byte stream.
        :param textureUri: the URI of the texture image.
        :param objects_type: a class name among CityMCityObject derived classes.
        :param cursor: a database access cursor
        :return: an image as bytes
        &#34;&#34;&#34;
        imageBinaryData = objects_type.retrieve_textures(
            cursor,
            textureUri,
            objects_type)
        LEFT_THUMB = imageBinaryData[0][0]
        stream = BytesIO(LEFT_THUMB)
        return stream

    @staticmethod
    def sql_query_centroid():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def sql_query_geometries_with_texture_coordinates():
        &#34;&#34;&#34;
        Virtual method: all CityMCityObjects and childs classes instances should
        implement this method.

        :return: no return value.
        &#34;&#34;&#34;
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="py3dtilers.Common.feature.FeatureList" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList">FeatureList</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="py3dtilers.CityTiler.citym_bridge.CityMBridges" href="citym_bridge.html#py3dtilers.CityTiler.citym_bridge.CityMBridges">CityMBridges</a></li>
<li><a title="py3dtilers.CityTiler.citym_building.CityMBuildings" href="citym_building.html#py3dtilers.CityTiler.citym_building.CityMBuildings">CityMBuildings</a></li>
<li><a title="py3dtilers.CityTiler.citym_relief.CityMReliefs" href="citym_relief.html#py3dtilers.CityTiler.citym_relief.CityMReliefs">CityMReliefs</a></li>
<li><a title="py3dtilers.CityTiler.citym_waterbody.CityMWaterBodies" href="citym_waterbody.html#py3dtilers.CityTiler.citym_waterbody.CityMWaterBodies">CityMWaterBodies</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.gml_cursor"><code class="name">var <span class="ident">gml_cursor</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.object_type"><code class="name">var <span class="ident">object_type</span></code></dt>
<dd>
<div class="desc"><p>The base class of all thematic classes within CityGMLâ€™s data model is the abstract class
_CityObject. (cf 3DCityDB Version 3.3.0 Documentation).</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.get_cursor"><code class="name flex">
<span>def <span class="ident">get_cursor</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current cursor to be able to execute queries in the database.
:return: the cursor of the current database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_cursor():
    &#34;&#34;&#34;
    Return the current cursor to be able to execute queries in the database.
    :return: the cursor of the current database
    &#34;&#34;&#34;
    return CityMCityObjects.gml_cursor</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.get_image_from_binary"><code class="name flex">
<span>def <span class="ident">get_image_from_binary</span></span>(<span>textureUri, objects_type, cursor)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the texture image as a byte stream.
:param textureUri: the URI of the texture image.
:param objects_type: a class name among CityMCityObject derived classes.
:param cursor: a database access cursor
:return: an image as bytes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_image_from_binary(textureUri, objects_type, cursor):
    &#34;&#34;&#34;
    Return the texture image as a byte stream.
    :param textureUri: the URI of the texture image.
    :param objects_type: a class name among CityMCityObject derived classes.
    :param cursor: a database access cursor
    :return: an image as bytes
    &#34;&#34;&#34;
    imageBinaryData = objects_type.retrieve_textures(
        cursor,
        textureUri,
        objects_type)
    LEFT_THUMB = imageBinaryData[0][0]
    stream = BytesIO(LEFT_THUMB)
    return stream</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.retrieve_objects"><code class="name flex">
<span>def <span class="ident">retrieve_objects</span></span>(<span>cursor, objects_type, cityobjects=[], citygml_ids=[])</span>
</code></dt>
<dd>
<div class="desc"><p>:param cursor: a database access cursor.
:param objects_type: a class name among CityMCityObject derived classes.
For example, objects_type can be "CityMBuilding".</p>
<p>:param cityobjects: a list of objects_type type object that should be
sought in the database. When this list is empty all
the objects encountered in the database are returned.</p>
<p>:param citygml_ids: a list of cityGML IDs. If the list isn't empty, we keep only
the city objects of the list</p>
<p>:return: an objects_type type object containing the objects that were retrieved
in the 3DCityDB database, each object being decorated with its database
identifier as well as its 3D bounding box (as retrieved in the database).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def retrieve_objects(cursor, objects_type, cityobjects=list(), citygml_ids=list()):
    &#34;&#34;&#34;
    :param cursor: a database access cursor.
    :param objects_type: a class name among CityMCityObject derived classes.
                    For example, objects_type can be &#34;CityMBuilding&#34;.

    :param cityobjects: a list of objects_type type object that should be
                    sought in the database. When this list is empty all
                    the objects encountered in the database are returned.

    :param citygml_ids: a list of cityGML IDs. If the list isn&#39;t empty, we keep only
                    the city objects of the list

    :return: an objects_type type object containing the objects that were retrieved
            in the 3DCityDB database, each object being decorated with its database
            identifier as well as its 3D bounding box (as retrieved in the database).
    &#34;&#34;&#34;
    if not cityobjects:
        no_input = True
    else:
        no_input = False
    cursor.execute(objects_type.sql_query_objects(cityobjects, citygml_ids))

    if no_input:
        result_objects = objects_type()
        object_type = objects_type.object_type
    else:
        # We need to deal with the fact that the answer will (generically)
        # not preserve the order of the objects that was given to the query
        objects_with_gmlid_key = dict()
        for cityobject in cityobjects:
            objects_with_gmlid_key[cityobject.get_gml_id()] = cityobject

    for obj in cursor.fetchall():
        object_id = obj[0]
        gml_id = obj[1]
        if no_input:
            new_object = object_type(object_id, gml_id)
            result_objects.append(new_object)
        else:
            cityobject = objects_with_gmlid_key[gml_id]
            cityobject.set_database_id(object_id)
            cityobject.set_gml_id(gml_id)
    if no_input:
        return result_objects
    else:
        return cityobjects</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.retrieve_textures"><code class="name flex">
<span>def <span class="ident">retrieve_textures</span></span>(<span>cursor, image_uri, objects_type)</span>
</code></dt>
<dd>
<div class="desc"><p>:param cursor: a database access cursor
:param image_uri: the uri (as string) of the texture to select in the database
:param objects_type: a class name among CityMCityObject derived classes.
For example, objects_type can be "CityMBuilding".
:rtype List: the binary data of the texture image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def retrieve_textures(cursor, image_uri, objects_type):
    &#34;&#34;&#34;
    :param cursor: a database access cursor
    :param image_uri: the uri (as string) of the texture to select in the database
    :param objects_type: a class name among CityMCityObject derived classes.
                    For example, objects_type can be &#34;CityMBuilding&#34;.
    :rtype List: the binary data of the texture image
    &#34;&#34;&#34;
    res = []
    cursor.execute(objects_type.sql_query_textures(image_uri))
    for t in cursor.fetchall():
        res.append(t)
    return(res)</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.set_cursor"><code class="name flex">
<span>def <span class="ident">set_cursor</span></span>(<span>cursor)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the CityMCityObjects cursor to the current cursor to be able to execute queries in the database.
:param cursor: the cursor of the current database</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_cursor(cursor):
    &#34;&#34;&#34;
    Set the CityMCityObjects cursor to the current cursor to be able to execute queries in the database.
    :param cursor: the cursor of the current database
    &#34;&#34;&#34;
    CityMCityObjects.gml_cursor = cursor</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_centroid"><code class="name flex">
<span>def <span class="ident">sql_query_centroid</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Virtual method: all CityMCityObjects and childs classes instances should
implement this method.</p>
<p>:return: no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sql_query_centroid():
    &#34;&#34;&#34;
    Virtual method: all CityMCityObjects and childs classes instances should
    implement this method.

    :return: no return value.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_geometries"><code class="name flex">
<span>def <span class="ident">sql_query_geometries</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Virtual method: all CityMCityObjects and childs classes instances should
implement this method.</p>
<p>:return: no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sql_query_geometries():
    &#34;&#34;&#34;
    Virtual method: all CityMCityObjects and childs classes instances should
    implement this method.

    :return: no return value.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_geometries_with_texture_coordinates"><code class="name flex">
<span>def <span class="ident">sql_query_geometries_with_texture_coordinates</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Virtual method: all CityMCityObjects and childs classes instances should
implement this method.</p>
<p>:return: no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sql_query_geometries_with_texture_coordinates():
    &#34;&#34;&#34;
    Virtual method: all CityMCityObjects and childs classes instances should
    implement this method.

    :return: no return value.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_objects"><code class="name flex">
<span>def <span class="ident">sql_query_objects</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Virtual method: all CityMCityObjects and childs classes instances should
implement this method.</p>
<p>:return: no return value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sql_query_objects():
    &#34;&#34;&#34;
    Virtual method: all CityMCityObjects and childs classes instances should
    implement this method.

    :return: no return value.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_textures"><code class="name flex">
<span>def <span class="ident">sql_query_textures</span></span>(<span>image_uri)</span>
</code></dt>
<dd>
<div class="desc"><p>:param image_uri: a string which is the uri of the texture to select in the database
:return: a string containing the right SQL query that should be executed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sql_query_textures(image_uri):
    &#34;&#34;&#34;
    :param image_uri: a string which is the uri of the texture to select in the database
    :return: a string containing the right SQL query that should be executed.
    &#34;&#34;&#34;

    query = \
        &#34;SELECT tex_image_data FROM citydb.tex_image WHERE tex_image_uri = &#39;&#34; + image_uri + &#34;&#39; &#34;
    return query</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="py3dtilers.Common.feature.FeatureList" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList">FeatureList</a></b></code>:
<ul class="hlist">
<li><code><a title="py3dtilers.Common.feature.FeatureList.add_material" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.add_material">add_material</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.add_materials" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.add_materials">add_materials</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.change_crs" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.change_crs">change_crs</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.create_batch_table_extension" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.create_batch_table_extension">create_batch_table_extension</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.create_bounding_volume_extension" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.create_bounding_volume_extension">create_bounding_volume_extension</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.delete_features_ref" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.delete_features_ref">delete_features_ref</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.get_centroid" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.get_centroid">get_centroid</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.get_color_config" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.get_color_config">get_color_config</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.get_features" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.get_features">get_features</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.get_material" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.get_material">get_material</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.get_material_index" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.get_material_index">get_material_index</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.get_textures" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.get_textures">get_textures</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.is_list_of_feature_list" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.is_list_of_feature_list">is_list_of_feature_list</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.is_material_registered" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.is_material_registered">is_material_registered</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.scale_features" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.scale_features">scale_features</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.set_color_config" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.set_color_config">set_color_config</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.set_features" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.set_features">set_features</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.set_features_geom" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.set_features_geom">set_features_geom</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.set_materials" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.set_materials">set_materials</a></code></li>
<li><code><a title="py3dtilers.Common.feature.FeatureList.translate_features" href="../Common/feature.html#py3dtilers.Common.feature.FeatureList.translate_features">translate_features</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="py3dtilers.CityTiler" href="index.html">py3dtilers.CityTiler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject">CityMCityObject</a></code></h4>
<ul class="two-column">
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_database_id" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_database_id">get_database_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_geom" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_geom">get_geom</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_gml_id" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject.get_gml_id">get_gml_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.has_texture" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject.has_texture">has_texture</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.set_database_id" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject.set_database_id">set_database_id</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObject.set_gml_id" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObject.set_gml_id">set_gml_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects">CityMCityObjects</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.get_cursor" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.get_cursor">get_cursor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.get_image_from_binary" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.get_image_from_binary">get_image_from_binary</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.gml_cursor" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.gml_cursor">gml_cursor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.object_type" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.object_type">object_type</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.retrieve_objects" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.retrieve_objects">retrieve_objects</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.retrieve_textures" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.retrieve_textures">retrieve_textures</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.set_cursor" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.set_cursor">set_cursor</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_centroid" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_centroid">sql_query_centroid</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_geometries" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_geometries">sql_query_geometries</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_geometries_with_texture_coordinates" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_geometries_with_texture_coordinates">sql_query_geometries_with_texture_coordinates</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_objects" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_objects">sql_query_objects</a></code></li>
<li><code><a title="py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_textures" href="#py3dtilers.CityTiler.citym_cityobject.CityMCityObjects.sql_query_textures">sql_query_textures</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>