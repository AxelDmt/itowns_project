<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>py3dtilers.Common.tileset_creation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>py3dtilers.Common.tileset_creation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from pyproj import Transformer
from py3dtiles import B3dm, BatchTable, BoundingVolumeBox, GlTF, GlTFMaterial
from py3dtiles import Tile, TileSet
from ..Texture import Atlas
from ..Common import ObjWriter
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..Common import GeometryNode, GeometryTree, FeatureList


class FromGeometryTreeToTileset():
    &#34;&#34;&#34;
    A static class to create a 3DTiles tileset from a GeometryTree.
    &#34;&#34;&#34;

    tile_index = 0
    nb_nodes = 0

    @staticmethod
    def convert_to_tileset(geometry_tree: &#39;GeometryTree&#39;, user_arguments=None, extension_name=None, output_dir=None):
        &#34;&#34;&#34;
        Recursively creates a tileset from the nodes of a GeometryTree
        :param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
        :param user_arguments: the Namespace containing the arguments of the command line.
        :param extension_name: the name of an extension to add to the tileset.
        :param output_dir: the directory where the TileSet is writen.

        :return: a TileSet
        &#34;&#34;&#34;
        print(&#39;Creating tileset from features...&#39;)
        tileset = TileSet()
        FromGeometryTreeToTileset.tile_index = 0
        FromGeometryTreeToTileset.nb_nodes = geometry_tree.get_number_of_nodes()
        obj_writer = ObjWriter()
        while len(geometry_tree.root_nodes) &gt; 0:
            root_node = geometry_tree.root_nodes[0]
            root_node.set_node_features_geometry(user_arguments)
            FromGeometryTreeToTileset.__transform_node(root_node, user_arguments, obj_writer=obj_writer)
            centroid = root_node.feature_list.get_centroid()
            tileset.add_tile(FromGeometryTreeToTileset.__create_tile(root_node, centroid, centroid, extension_name, output_dir))
            geometry_tree.root_nodes.remove(root_node)

        if user_arguments.obj is not None:
            obj_writer.write_obj(user_arguments.obj)
        tileset.get_root_tile().set_bounding_volume(BoundingVolumeBox())
        print(&#34;\r&#34; + str(FromGeometryTreeToTileset.tile_index), &#34;/&#34;, str(FromGeometryTreeToTileset.nb_nodes), &#34;tiles created&#34;, flush=True)
        return tileset

    @staticmethod
    def __transform_node(node: &#39;GeometryNode&#39;, user_args, obj_writer=None):
        &#34;&#34;&#34;
        Apply transformations on the features contained in a node.
        Those transformations are based on the arguments of the user.
        The features can also be writen in an OBJ file.
        :param node: the GeometryNode to transform.
        :param user_args: the Namespace containing the arguments of the command line.
        :param obj_writer: the writer used to create the OBJ model.
        &#34;&#34;&#34;
        if hasattr(user_args, &#39;scale&#39;) and user_args.scale:
            for feature_list in node.get_features():
                feature_list.scale_features(user_args.scale)

        if not all(v == 0 for v in user_args.offset) or user_args.offset[0] == &#39;centroid&#39;:
            if user_args.offset[0] == &#39;centroid&#39;:
                user_args.offset = node.feature_list.get_centroid()
            for feature_list in node.get_features():
                feature_list.translate_features(user_args.offset)

        if not user_args.crs_in == user_args.crs_out:
            transformer = Transformer.from_crs(user_args.crs_in, user_args.crs_out)
            for feature_list in node.get_features():
                feature_list.change_crs(transformer)

        if user_args.obj is not None:
            for leaf in node.get_leaves():
                obj_writer.add_geometries(leaf.feature_list)

    @staticmethod
    def __create_tile(node: &#39;GeometryNode&#39;, centroid, transform_offset, extension_name=None, output_dir=None):
        &#34;&#34;&#34;
        Create a tile from a node. Recursively create tiles from the children of the node.
        :param node: the GeometryNode.
        :param centroid: the centroid of the tile.
        :param transform_offset: the X,Y,Z position of the tile, relative to its parent&#39;s position.
        :param extension_name: the name of the extension to create.
        :param output_dir: the directory where the tiles will be created.
        &#34;&#34;&#34;
        print(&#34;\r&#34; + str(FromGeometryTreeToTileset.tile_index), &#34;/&#34;, str(FromGeometryTreeToTileset.nb_nodes), &#34;tiles created&#34;, end=&#39;&#39;, flush=True)
        feature_list = node.feature_list
        feature_list.translate_features(-centroid)

        tile = Tile()
        tile.set_geometric_error(node.geometric_error)

        content_b3dm = FromGeometryTreeToTileset.__create_tile_content(feature_list, extension_name, node.has_texture())
        tile.set_content(content_b3dm)
        tile.set_content_uri(&#39;tiles/&#39; + f&#39;{FromGeometryTreeToTileset.tile_index}.b3dm&#39;)
        tile.write_content(output_dir)
        del tile.attributes[&#34;content&#34;].body  # Delete the binary body of the tile once writen on disk to free the memory

        # Set the position of the tile. The position is relative to the parent tile&#39;s position
        tile.set_transform([1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            transform_offset[0], transform_offset[1], transform_offset[2], 1])
        tile.set_refine_mode(&#39;REPLACE&#39;)
        bounding_box = BoundingVolumeBox()
        for feature in feature_list:
            bounding_box.add(feature.get_bounding_volume_box())

        if extension_name is not None:
            extension = feature_list.__class__.create_bounding_volume_extension(extension_name, None, feature_list)
            if extension is not None:
                bounding_box.add_extension(extension)

        tile.set_bounding_volume(bounding_box)

        del node.feature_list

        FromGeometryTreeToTileset.tile_index += 1
        for child_node in node.child_nodes:
            tile.add_child(FromGeometryTreeToTileset.__create_tile(child_node, centroid, [0., 0., 0.], extension_name, output_dir))

        return tile

    @staticmethod
    def __create_tile_content(feature_list: &#39;FeatureList&#39;, extension_name=None, with_texture=False):
        &#34;&#34;&#34;
        :param pre_tile: an array containing features of a single tile

        :return: a B3dm tile.
        &#34;&#34;&#34;
        # create B3DM content
        arrays = []
        materials = []
        seen_mat_indexes = dict()
        if with_texture:
            tile_atlas = Atlas(feature_list)
            materials = [GlTFMaterial(textureUri=&#39;./&#39; + tile_atlas.id)]
        for feature in feature_list:
            mat_index = feature.material_index
            if mat_index not in seen_mat_indexes and not with_texture:
                seen_mat_indexes[mat_index] = len(materials)
                materials.append(feature_list.get_material(mat_index))
            content = {
                &#39;position&#39;: feature.geom.getPositionArray(),
                &#39;normal&#39;: feature.geom.getNormalArray(),
                &#39;bbox&#39;: [[float(i) for i in j] for j in feature.geom.getBbox()],
                &#39;matIndex&#39;: seen_mat_indexes[mat_index] if not with_texture else 0
            }
            if with_texture:
                content[&#39;uv&#39;] = feature.geom.getDataArray(0)
            arrays.append(content)

        # GlTF uses a y-up coordinate system whereas the geographical data (stored
        # in the 3DCityDB database) uses a z-up coordinate system convention. In
        # order to comply with Gltf we thus need to realize a z-up to y-up
        # coordinate transform for the data to respect the glTF convention. This
        # rotation gets &#34;corrected&#34; (taken care of) by the B3dm/gltf parser on the
        # client side when using (displaying) the data.
        # Refer to the note concerning the recommended data workflow
        # https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#gltf-transforms
        # for more details on this matter.
        transform = np.array([1, 0, 0, 0,
                              0, 0, -1, 0,
                              0, 1, 0, 0,
                              0, 0, 0, 1])

        gltf = GlTF.from_binary_arrays(arrays, transform, materials=materials)

        # Create a batch table and add the ID of each feature to it
        ids = [feature.get_id() for feature in feature_list]
        bt = BatchTable()
        bt.add_property_from_array(&#34;id&#34;, ids)

        # if there is application specific data associated with the features, add it to the batch table
        features_data = [feature.get_batchtable_data() for feature in feature_list]
        if not all([feature_data is None for feature_data in features_data]):
            # Construct a set of all possible batch table keys
            bt_keys = set()
            for key_subset in [feature_data.keys() for feature_data in features_data]:
                bt_keys = bt_keys.union(set(key_subset))
            # add feature data to batch table based on possible keys
            for key in bt_keys:
                key_data = [feature_data.get(key, None) for feature_data in features_data]
                bt.add_property_from_array(key, key_data)

        if extension_name is not None:
            extension = feature_list.__class__.create_batch_table_extension(extension_name, ids, feature_list)
            if extension is not None:
                bt.add_extension(extension)

        # Eventually wrap the features together with the optional
        # BatchTableHierarchy within a B3dm:
        return B3dm.from_glTF(gltf, bt=bt)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset"><code class="flex name class">
<span>class <span class="ident">FromGeometryTreeToTileset</span></span>
</code></dt>
<dd>
<div class="desc"><p>A static class to create a 3DTiles tileset from a GeometryTree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FromGeometryTreeToTileset():
    &#34;&#34;&#34;
    A static class to create a 3DTiles tileset from a GeometryTree.
    &#34;&#34;&#34;

    tile_index = 0
    nb_nodes = 0

    @staticmethod
    def convert_to_tileset(geometry_tree: &#39;GeometryTree&#39;, user_arguments=None, extension_name=None, output_dir=None):
        &#34;&#34;&#34;
        Recursively creates a tileset from the nodes of a GeometryTree
        :param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
        :param user_arguments: the Namespace containing the arguments of the command line.
        :param extension_name: the name of an extension to add to the tileset.
        :param output_dir: the directory where the TileSet is writen.

        :return: a TileSet
        &#34;&#34;&#34;
        print(&#39;Creating tileset from features...&#39;)
        tileset = TileSet()
        FromGeometryTreeToTileset.tile_index = 0
        FromGeometryTreeToTileset.nb_nodes = geometry_tree.get_number_of_nodes()
        obj_writer = ObjWriter()
        while len(geometry_tree.root_nodes) &gt; 0:
            root_node = geometry_tree.root_nodes[0]
            root_node.set_node_features_geometry(user_arguments)
            FromGeometryTreeToTileset.__transform_node(root_node, user_arguments, obj_writer=obj_writer)
            centroid = root_node.feature_list.get_centroid()
            tileset.add_tile(FromGeometryTreeToTileset.__create_tile(root_node, centroid, centroid, extension_name, output_dir))
            geometry_tree.root_nodes.remove(root_node)

        if user_arguments.obj is not None:
            obj_writer.write_obj(user_arguments.obj)
        tileset.get_root_tile().set_bounding_volume(BoundingVolumeBox())
        print(&#34;\r&#34; + str(FromGeometryTreeToTileset.tile_index), &#34;/&#34;, str(FromGeometryTreeToTileset.nb_nodes), &#34;tiles created&#34;, flush=True)
        return tileset

    @staticmethod
    def __transform_node(node: &#39;GeometryNode&#39;, user_args, obj_writer=None):
        &#34;&#34;&#34;
        Apply transformations on the features contained in a node.
        Those transformations are based on the arguments of the user.
        The features can also be writen in an OBJ file.
        :param node: the GeometryNode to transform.
        :param user_args: the Namespace containing the arguments of the command line.
        :param obj_writer: the writer used to create the OBJ model.
        &#34;&#34;&#34;
        if hasattr(user_args, &#39;scale&#39;) and user_args.scale:
            for feature_list in node.get_features():
                feature_list.scale_features(user_args.scale)

        if not all(v == 0 for v in user_args.offset) or user_args.offset[0] == &#39;centroid&#39;:
            if user_args.offset[0] == &#39;centroid&#39;:
                user_args.offset = node.feature_list.get_centroid()
            for feature_list in node.get_features():
                feature_list.translate_features(user_args.offset)

        if not user_args.crs_in == user_args.crs_out:
            transformer = Transformer.from_crs(user_args.crs_in, user_args.crs_out)
            for feature_list in node.get_features():
                feature_list.change_crs(transformer)

        if user_args.obj is not None:
            for leaf in node.get_leaves():
                obj_writer.add_geometries(leaf.feature_list)

    @staticmethod
    def __create_tile(node: &#39;GeometryNode&#39;, centroid, transform_offset, extension_name=None, output_dir=None):
        &#34;&#34;&#34;
        Create a tile from a node. Recursively create tiles from the children of the node.
        :param node: the GeometryNode.
        :param centroid: the centroid of the tile.
        :param transform_offset: the X,Y,Z position of the tile, relative to its parent&#39;s position.
        :param extension_name: the name of the extension to create.
        :param output_dir: the directory where the tiles will be created.
        &#34;&#34;&#34;
        print(&#34;\r&#34; + str(FromGeometryTreeToTileset.tile_index), &#34;/&#34;, str(FromGeometryTreeToTileset.nb_nodes), &#34;tiles created&#34;, end=&#39;&#39;, flush=True)
        feature_list = node.feature_list
        feature_list.translate_features(-centroid)

        tile = Tile()
        tile.set_geometric_error(node.geometric_error)

        content_b3dm = FromGeometryTreeToTileset.__create_tile_content(feature_list, extension_name, node.has_texture())
        tile.set_content(content_b3dm)
        tile.set_content_uri(&#39;tiles/&#39; + f&#39;{FromGeometryTreeToTileset.tile_index}.b3dm&#39;)
        tile.write_content(output_dir)
        del tile.attributes[&#34;content&#34;].body  # Delete the binary body of the tile once writen on disk to free the memory

        # Set the position of the tile. The position is relative to the parent tile&#39;s position
        tile.set_transform([1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            transform_offset[0], transform_offset[1], transform_offset[2], 1])
        tile.set_refine_mode(&#39;REPLACE&#39;)
        bounding_box = BoundingVolumeBox()
        for feature in feature_list:
            bounding_box.add(feature.get_bounding_volume_box())

        if extension_name is not None:
            extension = feature_list.__class__.create_bounding_volume_extension(extension_name, None, feature_list)
            if extension is not None:
                bounding_box.add_extension(extension)

        tile.set_bounding_volume(bounding_box)

        del node.feature_list

        FromGeometryTreeToTileset.tile_index += 1
        for child_node in node.child_nodes:
            tile.add_child(FromGeometryTreeToTileset.__create_tile(child_node, centroid, [0., 0., 0.], extension_name, output_dir))

        return tile

    @staticmethod
    def __create_tile_content(feature_list: &#39;FeatureList&#39;, extension_name=None, with_texture=False):
        &#34;&#34;&#34;
        :param pre_tile: an array containing features of a single tile

        :return: a B3dm tile.
        &#34;&#34;&#34;
        # create B3DM content
        arrays = []
        materials = []
        seen_mat_indexes = dict()
        if with_texture:
            tile_atlas = Atlas(feature_list)
            materials = [GlTFMaterial(textureUri=&#39;./&#39; + tile_atlas.id)]
        for feature in feature_list:
            mat_index = feature.material_index
            if mat_index not in seen_mat_indexes and not with_texture:
                seen_mat_indexes[mat_index] = len(materials)
                materials.append(feature_list.get_material(mat_index))
            content = {
                &#39;position&#39;: feature.geom.getPositionArray(),
                &#39;normal&#39;: feature.geom.getNormalArray(),
                &#39;bbox&#39;: [[float(i) for i in j] for j in feature.geom.getBbox()],
                &#39;matIndex&#39;: seen_mat_indexes[mat_index] if not with_texture else 0
            }
            if with_texture:
                content[&#39;uv&#39;] = feature.geom.getDataArray(0)
            arrays.append(content)

        # GlTF uses a y-up coordinate system whereas the geographical data (stored
        # in the 3DCityDB database) uses a z-up coordinate system convention. In
        # order to comply with Gltf we thus need to realize a z-up to y-up
        # coordinate transform for the data to respect the glTF convention. This
        # rotation gets &#34;corrected&#34; (taken care of) by the B3dm/gltf parser on the
        # client side when using (displaying) the data.
        # Refer to the note concerning the recommended data workflow
        # https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#gltf-transforms
        # for more details on this matter.
        transform = np.array([1, 0, 0, 0,
                              0, 0, -1, 0,
                              0, 1, 0, 0,
                              0, 0, 0, 1])

        gltf = GlTF.from_binary_arrays(arrays, transform, materials=materials)

        # Create a batch table and add the ID of each feature to it
        ids = [feature.get_id() for feature in feature_list]
        bt = BatchTable()
        bt.add_property_from_array(&#34;id&#34;, ids)

        # if there is application specific data associated with the features, add it to the batch table
        features_data = [feature.get_batchtable_data() for feature in feature_list]
        if not all([feature_data is None for feature_data in features_data]):
            # Construct a set of all possible batch table keys
            bt_keys = set()
            for key_subset in [feature_data.keys() for feature_data in features_data]:
                bt_keys = bt_keys.union(set(key_subset))
            # add feature data to batch table based on possible keys
            for key in bt_keys:
                key_data = [feature_data.get(key, None) for feature_data in features_data]
                bt.add_property_from_array(key, key_data)

        if extension_name is not None:
            extension = feature_list.__class__.create_batch_table_extension(extension_name, ids, feature_list)
            if extension is not None:
                bt.add_extension(extension)

        # Eventually wrap the features together with the optional
        # BatchTableHierarchy within a B3dm:
        return B3dm.from_glTF(gltf, bt=bt)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.nb_nodes"><code class="name">var <span class="ident">nb_nodes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.tile_index"><code class="name">var <span class="ident">tile_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.convert_to_tileset"><code class="name flex">
<span>def <span class="ident">convert_to_tileset</span></span>(<span>geometry_tree: GeometryTree, user_arguments=None, extension_name=None, output_dir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively creates a tileset from the nodes of a GeometryTree
:param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
:param user_arguments: the Namespace containing the arguments of the command line.
:param extension_name: the name of an extension to add to the tileset.
:param output_dir: the directory where the TileSet is writen.</p>
<p>:return: a TileSet</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def convert_to_tileset(geometry_tree: &#39;GeometryTree&#39;, user_arguments=None, extension_name=None, output_dir=None):
    &#34;&#34;&#34;
    Recursively creates a tileset from the nodes of a GeometryTree
    :param geometry_tree: an instance of GeometryTree to transform into 3DTiles.
    :param user_arguments: the Namespace containing the arguments of the command line.
    :param extension_name: the name of an extension to add to the tileset.
    :param output_dir: the directory where the TileSet is writen.

    :return: a TileSet
    &#34;&#34;&#34;
    print(&#39;Creating tileset from features...&#39;)
    tileset = TileSet()
    FromGeometryTreeToTileset.tile_index = 0
    FromGeometryTreeToTileset.nb_nodes = geometry_tree.get_number_of_nodes()
    obj_writer = ObjWriter()
    while len(geometry_tree.root_nodes) &gt; 0:
        root_node = geometry_tree.root_nodes[0]
        root_node.set_node_features_geometry(user_arguments)
        FromGeometryTreeToTileset.__transform_node(root_node, user_arguments, obj_writer=obj_writer)
        centroid = root_node.feature_list.get_centroid()
        tileset.add_tile(FromGeometryTreeToTileset.__create_tile(root_node, centroid, centroid, extension_name, output_dir))
        geometry_tree.root_nodes.remove(root_node)

    if user_arguments.obj is not None:
        obj_writer.write_obj(user_arguments.obj)
    tileset.get_root_tile().set_bounding_volume(BoundingVolumeBox())
    print(&#34;\r&#34; + str(FromGeometryTreeToTileset.tile_index), &#34;/&#34;, str(FromGeometryTreeToTileset.nb_nodes), &#34;tiles created&#34;, flush=True)
    return tileset</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="py3dtilers.Common" href="index.html">py3dtilers.Common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset" href="#py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset">FromGeometryTreeToTileset</a></code></h4>
<ul class="">
<li><code><a title="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.convert_to_tileset" href="#py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.convert_to_tileset">convert_to_tileset</a></code></li>
<li><code><a title="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.nb_nodes" href="#py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.nb_nodes">nb_nodes</a></code></li>
<li><code><a title="py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.tile_index" href="#py3dtilers.Common.tileset_creation.FromGeometryTreeToTileset.tile_index">tile_index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>